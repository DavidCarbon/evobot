import { AudioPlayerStatus, createAudioResource, entersState, StreamType, VoiceConnectionStatus } from "@discordjs/voice";â€¨import SoundCloud from "soundcloud-downloader";â€¨import ytdl from "ytdl-core-discord";â€¨import { config } from "../utils/config.js";â€¨import { i18n } from "../utils/i18n.js";â€¨import { canModifyQueue } from "../utils/queue.js";â€¨â€¨const { PRUNING, STAY_TIME } = config;â€¨const scdl = SoundCloud.create();â€¨â€¨export async function processQueue(song, message)â€¨{â€¨    const queue = message.client.queue.get(message.guild.id);â€¨â€¨    if (message.guild?.me?.voice.channel?.members.size <= 1)â€¨    {â€¨        tryâ€¨        {â€¨            setTimeout(function ()â€¨            {â€¨                tryâ€¨                {â€¨                    if (canModifyQueue(message.member) && !message.client.queue.get(message.guild.id))â€¨                    {â€¨                        queue.player.stop();â€¨                        if (queue.connection != null)â€¨                        {â€¨                            if (queue.connection.state != null)â€¨                            {â€¨                                if (queue.connection.state.status !== VoiceConnectionStatus.Destroyed)â€¨                                {â€¨                                    queue.connection.destroy();â€¨                                    queue.connection = null;â€¨                                }â€¨                            }â€¨                        }â€¨                    }â€¨                }â€¨                catch (error)â€¨                {â€¨                    console.error(error);â€¨                }â€¨            }, STAY_TIME * 1000);â€¨â€¨            if (queue.textChannel != null && !PRUNING)â€¨            {â€¨                queue.textChannel.send(i18n.__("play.queueEnded")).catch(console.error);â€¨            }â€¨â€¨            await entersState(queue.player, AudioPlayerStatus.Idle, 5e3);â€¨â€¨            return message.client.queue.delete(message.guild.id);â€¨        }â€¨        catch (error)â€¨        {â€¨            console.error(error);â€¨        }â€¨    }â€¨    elseâ€¨    {â€¨        if (!song)â€¨        {â€¨            setTimeout(function ()â€¨            {â€¨                tryâ€¨                {â€¨                    if (canModifyQueue(message.member) && !message.client.queue.get(message.guild.id))â€¨                    {â€¨                        queue.player.stop();â€¨                        if (queue.connection != null)â€¨                        {â€¨                            if (queue.connection.state != null)â€¨                            {â€¨                                if (queue.connection.state.status !== VoiceConnectionStatus.Destroyed)â€¨                                {â€¨                                    queue.connection.destroy();â€¨                                    queue.connection = null;â€¨                                }â€¨                            }â€¨                        }â€¨                    }â€¨                }â€¨                catch (error)â€¨                {â€¨                    console.error(error);â€¨                }â€¨            }, STAY_TIME * 1000);â€¨â€¨            if (queue.textChannel != null && !PRUNING)â€¨            {â€¨                queue.textChannel.send(i18n.__("play.queueEnded")).catch(console.error);â€¨            }â€¨â€¨            await entersState(queue.player, AudioPlayerStatus.Idle, 5e3);â€¨â€¨            return message.client.queue.delete(message.guild.id);â€¨        }â€¨â€¨        if (queue.textChannel != null && !PRUNING)â€¨        {â€¨            queue.textChannel.send("Searching " + song.title).catch(console.error);â€¨        }â€¨â€¨        let stream = null;â€¨        let streamType = song.url.includes("youtube.com") ? StreamType.Opus : StreamType.OggOpus;â€¨â€¨        tryâ€¨        {â€¨            if (song.url.includes("youtube.com"))â€¨            {â€¨                stream = await ytdl(song.url, { highWaterMark: 1 << 25 });â€¨            }â€¨            else if (song.url.includes("soundcloud.com"))â€¨            {â€¨                tryâ€¨                {â€¨                    stream = await scdl.downloadFormat(song.url, 'audio/ogg; codecs="opus"');â€¨                }â€¨                catch (error)â€¨                {â€¨                    stream = await scdl.downloadFormat(song.url, "audio/mpeg");â€¨                    streamType = StreamType.Arbitrary;â€¨                }â€¨            }â€¨            else if (song.url.includes("http") && song.url.includes("://") && (song.url.endsWith(".mp3") || song.url.endsWith(".ogg")))â€¨            {â€¨                stream = song.url;â€¨                streamType = song.url.endsWith(".ogg") ? StreamType.OggOpus : StreamType.Arbitrary;â€¨            }â€¨            else if (song.url.includes("/sounds/") && (song.url.endsWith(".mp3") || song.url.endsWith(".ogg")))â€¨            {â€¨                stream = song.url;â€¨                streamType = song.url.endsWith(".ogg") ? StreamType.OggOpus : StreamType.Arbitrary;â€¨                song.url = "on Local Server";â€¨            }â€¨            elseâ€¨            {â€¨                if (queue)â€¨                {â€¨                    queue.songs.shift();â€¨                    processQueue(queue.songs[0], message);â€¨                }â€¨â€¨                return message.channel.send(i18n.__mf("play.queueError"));â€¨            }â€¨        }â€¨        catch (error)â€¨        {â€¨            if (queue)â€¨            {â€¨                queue.songs.shift();â€¨                processQueue(queue.songs[0], message);â€¨            }â€¨â€¨            console.error(error);â€¨â€¨            return message.channel.send(i18n.__mf("play.queueError", { error: error.message ? error.message : error }));â€¨        }â€¨â€¨        queue.resource = createAudioResource(stream, { inputType: streamType, inlineVolume: true });â€¨        queue.resource.volume?.setVolumeLogarithmic(queue.volume / 100);â€¨â€¨        queue.player.play(queue.resource);â€¨â€¨        await entersState(queue.player, AudioPlayerStatus.Playing, 5e3);â€¨â€¨        tryâ€¨        {â€¨            if (queue.textChannel != null)â€¨            {â€¨                var playingMessage = await queue.textChannel.send(i18n.__mf("play.startedPlaying", { title: song.title, url: song.url }));â€¨                if (queue.songs.length >= 2)â€¨                {â€¨                    await playingMessage.react("â­");â€¨                }â€¨                await playingMessage.react("ðŸ”");â€¨                if (queue.songs.length >= 3)â€¨                {â€¨                    await playingMessage.react("ðŸ”€");â€¨                }â€¨                await playingMessage.react("â¹");â€¨            }â€¨        }â€¨        catch (error)â€¨        {â€¨            console.error(error);â€¨â€¨            return message.reply(error.message);â€¨        }â€¨â€¨        const filter = (reaction, user) => user.id !== message.client.user.id;â€¨â€¨        var collector = playingMessage.createReactionCollector({â€¨            filter,â€¨            time: song.duration > 0 ? song.duration * 1000 : 600000â€¨        });â€¨â€¨        queue.collector = collector;â€¨â€¨        collector.on("collect", async (reaction, user) =>â€¨        {â€¨            if (!queue)â€¨            {â€¨                return;â€¨            }â€¨            elseâ€¨            {â€¨                const member = await message.guild.members.fetch(user);â€¨â€¨                switch (reaction.emoji.name)â€¨                {â€¨                    case "â­":â€¨                        reaction.users.remove(user).catch(console.error);â€¨                        await message.client.commands.get("skip").execute(message);â€¨                        break;â€¨                    case "â¯":â€¨                        reaction.users.remove(user).catch(console.error);â€¨                        if (queue.player.state.status == AudioPlayerStatus.Playing)â€¨                        {â€¨                            await message.client.commands.get("pause").execute(message);â€¨                            await entersState(queue.player, AudioPlayerStatus.Idle, 5e3);â€¨                        }â€¨                        elseâ€¨                        {â€¨                            await message.client.commands.get("resume").execute(message);â€¨                            await entersState(queue.player, AudioPlayerStatus.Playing, 5e3);â€¨                        }â€¨                        break;â€¨                    case "ðŸ”‡":â€¨                        reaction.users.remove(user).catch(console.error);â€¨                        if (!canModifyQueue(member, queue))â€¨                        {â€¨                            return i18n.__("common.errorNotChannel");â€¨                        }â€¨                        elseâ€¨                        {â€¨                            queue.muted = !queue.muted;â€¨                            if (queue.muted)â€¨                            {â€¨                                queue.resource.volume.setVolumeLogarithmic(0);â€¨                                if (queue.textChannel != null)â€¨                                {â€¨                                    queue.textChannel.send(i18n.__mf("play.mutedSong", { author: user })).catch(console.error);â€¨                                }â€¨                            }â€¨                            elseâ€¨                            {â€¨                                queue.resource.volume.setVolumeLogarithmic(queue.volume / 100);â€¨                                if (queue.textChannel != null)â€¨                                {â€¨                                    queue.textChannel.send(i18n.__mf("play.unmutedSong", { author: user })).catch(console.error);â€¨                                }â€¨                            }â€¨                        }â€¨                        break;â€¨                    case "ðŸ”‰":â€¨                        reaction.users.remove(user).catch(console.error);â€¨                        if (queue.volume == 0)â€¨                        {â€¨                            return;â€¨                        }â€¨                        else if (!canModifyQueue(member, queue))â€¨                        {â€¨                            return i18n.__("common.errorNotChannel");â€¨                        }â€¨                        elseâ€¨                        {â€¨                            queue.volume = Math.max(queue.volume - 10, 0);â€¨                            queue.resource.volume.setVolumeLogarithmic(queue.volume / 100);â€¨â€¨                            if (queue.textChannel != null)â€¨                            {â€¨                                queue.textChannelâ€¨                                    .send(i18n.__mf("play.decreasedVolume", { author: user, volume: queue.volume }))â€¨                                    .catch(console.error);â€¨                            }â€¨                        }â€¨                        break;â€¨                    case "ðŸ”Š":â€¨                        reaction.users.remove(user).catch(console.error);â€¨                        if (queue.volume == 100)â€¨                        {â€¨                            return;â€¨                        }â€¨                        else if (!canModifyQueue(member, queue))â€¨                        {â€¨                            return i18n.__("common.errorNotChannel");â€¨                        }â€¨                        elseâ€¨                        {â€¨                            queue.volume = Math.min(queue.volume + 10, 100);â€¨                            queue.resource.volume.setVolumeLogarithmic(queue.volume / 100);â€¨                            if (queue.textChannel != null)â€¨                            {â€¨                                queue.textChannelâ€¨                                    .send(i18n.__mf("play.increasedVolume", { author: user, volume: queue.volume }))â€¨                                    .catch(console.error);â€¨                            }â€¨                        }â€¨                        break;â€¨                    case "ðŸ”":â€¨                        reaction.users.remove(user).catch(console.error);â€¨                        await message.client.commands.get("loop").execute(message);â€¨                        break;â€¨â€¨                    case "ðŸ”€":â€¨                        reaction.users.remove(user).catch(console.error);â€¨                        await message.client.commands.get("shuffle").execute(message);â€¨                        break;â€¨â€¨                    case "â¹":â€¨                        reaction.users.remove(user).catch(console.error);â€¨                        await message.client.commands.get("stop").execute(message);â€¨                        collector.stop();â€¨                        queue.connection = null;â€¨                        break;â€¨â€¨                    default:â€¨                        reaction.users.remove(user).catch(console.error);â€¨                        break;â€¨                }â€¨            }â€¨        });â€¨â€¨        collector.on("end", () =>â€¨        {â€¨            playingMessage.reactions.removeAll().catch(console.error);â€¨â€¨            if (PRUNING)â€¨            {â€¨                setTimeout(() =>â€¨                {â€¨                    playingMessage.delete().catch();â€¨                }, 3000);â€¨            }â€¨        });â€¨    }â€¨}â€¨